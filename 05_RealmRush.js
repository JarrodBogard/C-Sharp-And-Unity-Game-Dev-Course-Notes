// Lesson 2: Realm Rush Game Design

// What is a "tower defense" game?
//  1. The player is able to place defensive structures.
//  2. The goal is to defend an objective from enemy attack.
//  3. There are waves of enemies that keep attacking the objective.

// Review at timestamp 2:30:00

// Lesson 3: Grid Snapping

// Review and notate!!!

// Lesson 4: Text Labels

// Review

// Lesson 5: Coordinate System

// Review & notate

// Lesson 6: Lists

// Review & notate specifically at timestamp 5:00:00

// Lesson 7: Introducing Coroutines

// Review & notate!!!

// Lesson 8: Importing Assets

// Review & notate at timestamp 4:30:00

// Lesson 9: Prefab Variants

// Review

// Lesson 10: Smooth Enemy Movement

// Review & notate !!!

// Lesson 11: Detect Mouse Input

// Lesson 12: Targeting Enemies

// Review

// Lesson 13: Damaging Enemies

// Lesson 14: Debugging Tools

// Review and notate!!!

// Lesson 15: Finding the Path

// Review

// Lesson 16: Instantiating Enemies

// Review & notate!

// Lesson 17: Object Pools

// !!! Review & notate !!!

// Lesson 18: Target Closest Enemy

// Review & notate!!!

// Lesson 19: Currency System (Part 1)

// !!! Review and notate !!!

// Lesson 20: Currency System (Part 2)

// !!! Review and notate !!!

// Lesson 21:  UI Text

// !!! Review and notate !!!

// Lesson 22: Increasing Difficulty

// !!! Review and notate !!!

// Lesson 23: Refactoring

// Lesson 24: Playtest and Balance

// Lesson 25: Pathfinding Decisions

// !!! Review & notate !!!

// Pathfinding options:
// 1. Breadth First Search (BFS) - simplest.
// 2. Dijkstra's - most accurate/sophisticated???
// 3. A* (a.k.a A Star) - most common in gaming???
//      - most complex???
//          - complexity doesn't always mean best.

// Starting with BFS, with some modifications it can be converted into Dijkstra's.
//      - Once converted to Dijkstra's, it can then be converted to A* by adding a heuristic.
//          - A* can be thought of as an extension of Dijkstra's.

// Lesson 26: Breadth First Search

// Review & notate!!!

// Lesson 27: Pure C# Classes

// !!! Review & notate !!!

// Lesson 28: Dictionaries

// !!! Review & notate !!!

// Lesson 29: More Debugging Tools

// Lesson 30: Exploring Neighbors

// !!! Review & notate !!!

// Lesson 31: Exploring the World

// Review & notate!!!

// Lesson 32: Finding the Path (again!)

// Review & notate!!!

// Lesson 33: Blocking Nodes

// Review!!!

// Lesson 34: Valid Path

// !!! Review & notate !!!

// Lesson 35: Script Execution Order

// !!! Review & notate !!!

// Lesson 36: Broadcast Message

// Review & notate!!!

// Lesson 37: Overloading Methods

// !!! Review & notate !!!

// Lesson 38: Build Timer

// !!! Review & notate !!!

// Lesson 39: Ambience

// Review!!!

// Lesson 40: Post Processing
